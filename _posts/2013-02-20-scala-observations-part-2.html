---
layout: post
title: Scala Observations - Part 2
categories:
- Scala
tags: []
status: publish
type: post
published: true
meta:
  _edit_last: '1'
---
<p>Spent most of this afternoon learning about the following topics in Scala: Objects, Packages, Inheritance, I/O, Traits, and Operators. Here are some of my notes.</p>
<ul>
	<li><span style="line-height: 13px;"><strong>Objects</strong>
</span>
<ul>
	<li>There are no static methods for classes in Scala, instead, create a companion object of the same name to define static methods.</li>
	<li>Common usage includes defining apply() in order to make object creation easier...like Array(1, 2, 3) is actually a call to the Array object's apply method which builds a new Array object with the values listed.</li>
	<li>Objects can extend classes or traits.</li>
	<li>Scala doesn't have enumerated types, but you can make an object that extends <em>Enumeration</em> in order to produce enumerations.</li>
	<li>
<pre class="lang:java decode:true ">object MutualFund extends Enumeration {
  type MutualFund = Value
  val MoneyMarket, Equity, PyramidScheme = Value
}</pre>
&nbsp;</li>
</ul>
</li>
	<li><strong>Packaging</strong>
<ul>
	<li>Fulfills the same purpose as in Java, but more flexible.</li>
	<li>Can declare packages anywhere anytime, and they aren't tied to directory structure.</li>
	<li>You can access all enclosing packages' scope.</li>
	<li>If you want to restrict scope or you don't need enclosing packages' scope you can used chained package declarations like <em>org.example.foo</em> in which you won't have access to <em>example </em>or <em>org</em> scope.</li>
	<li>If all code in the same file belongs to the same package, you can declare the package at the top, otherwise you have to nest them with brackets.</li>
	<li>If you want to have default package wide values or functions available, you can create a <em>package object.</em></li>
	<li>
<pre class="lang:default decode:true ">package object banks {
  val failureRate = .99
}

package banks {
  class Bank {
    var fail = failureRate // Constant from package
  }
}</pre>
&nbsp;</li>
	<li>Control visibility by using qualifiers on <em>private</em>, like <em>private[banks].</em></li>
	<li>Import wildcard is _ (* is a valid method name in Scala)</li>
	<li>Imports can be anywhere, not just top of the file. Things imported within blocks will only last until the end of that block. <em>Nice</em>.</li>
</ul>
</li>
	<li><strong>Inheritance</strong>
<ul>
	<li>Extends works similarly to how it does in Java.</li>
	<li>Any overrides <strong>require</strong> the <em>override</em> modifier, unless you are overriding an abstract method.</li>
	<li>Keyword <em>super</em> works similarly to Java.</li>
	<li><em>Protected</em> modifier gives visibility to subclasses.</li>
	<li>
<pre class="lang:java decode:true ">class BankAccount (initialBalance: Double) {
  protected var balance = initialBalance
  def deposit(amount: Double) = { balance += amount; balance }
  def withdraw(amount: Double) = { balance -= amount; balance }
}

class CheckingAccount(initialBalance: Double) extends BankAccount(initialBalance) {
  override def deposit(amount: Double) = { balance += amount - 1; balance }
  override def withdraw(amount: Double) = { balance -= amount + 1; balance }
}</pre>
&nbsp;</li>
	<li>Only the primary constructor can call the superclass constructor, and this is done simply in the class declaration.</li>
	<li>
<pre class="lang:java decode:true ">// CheckingAccount passes intialBalance to BankAccount constructor
class CheckingAccount(initialBalance: Double) extends BankAccount(initialBalance) {
  override def deposit(amount: Double) = { balance += amount - 1; balance }
  override def withdraw(amount: Double) = { balance -= amount + 1; balance }
}</pre>
&nbsp;</li>
	<li>You can extend Java classes in Scala</li>
	<li>Can't override <em>vars</em> unless abstract, but <em>vals </em>can be overwritten by other <em>vals; def </em>can be overridden by another <em>def </em>or by a <em>val </em>if the original <em>def</em> was parameter-less.</li>
	<li>
<pre class="lang:java decode:true ">abstract class Spaceship {
  val test:Int
  var test2:String
}

class Firefly extends Spaceship {
  val test = 23
  var test2 = "woah"
}</pre>
&nbsp;</li>
	<li>Abstract classes denoted by <em>abstract</em> modifier, to make abstract methods just omit the body, for abstract fields just don't set them to anything.</li>
	<li>You can't count on the value of a <em>val</em> in the body of a constructor, because the superclass is constructed before the subclass is.</li>
	<li>== will call the <em>equals</em> method</li>
	<li>When defining <em>equals</em> methods, the parameter of the other object should be of type <em>Any</em><em>.</em></li>
	<li><em>AnyRef </em>in Scala is the equivalent of <em>Object</em> in Java.</li>
</ul>
</li>
	<li><b>I/O</b>
<ul>
	<li><em>Scala.io.Source </em>holds many I/O operations.</li>
	<li><em>Source.fromFile() </em>opens files, <em>Source.fromURL, Source.fromString</em> also exist.</li>
	<li>Once you've opened a Source, you can easily turn it into a string with <em>mkString, </em>an array with <em>toArray</em>, a buffer with <em>toBuffer...</em>by default it is an iterator.</li>
	<li>You need to rely on Java for some file operations such as reading binaries or traversing directories.</li>
	<li><em>scala.sys.process</em> provides easy ways to interact with the shell. After importing, putting a ! after a string will run the contents of the string in the shell.</li>
	<li>Regex objects can be constructed by using the <em>r</em> method on Strings. If you use raw strings [triple quoted] you can avoid double backslash nastiness.</li>
</ul>
</li>
	<li><strong>Traits</strong>
<ul>
	<li>Kind of like Java interfaces, except when they aren't.</li>
	<li>You can implement multiple traits.</li>
	<li>Traits can just be abstract (like interfaces) or they can contain default implementations of methods or default values (unlike interfaces).</li>
	<li>You can <strong>mixin</strong> traits on a whim using the <em>with</em> keyword upon object creation</li>
	<li>
<pre class="lang:java decode:true ">// Pretend Log1 and Log2 have a method log.
val bar1 = new Foo with Log1
val bar2 = new Foo with Log2

bar1.log // calls Log1's log
bar2.log // calls Log2's log</pre>
&nbsp;</li>
	<li>Order of traits matters because a trait that uses <em>super</em> will refer to the next one in the trait hierarchy!</li>
	<li>If you extend a trait by a class, anything implementing that trait will now have that class as a superclass. A consequence of this is that if you are implementing a trait in a class that inherits from another class that isn't a subclass of the trait's class, you will get an error. <em>Phew.</em></li>
	<li>You can restrict what classes can implement what traits with type declarations.</li>
</ul>
</li>
	<li><strong>Operators</strong>
<ul>
	<li>Basically...You can make your own operators!</li>
</ul>
</li>
</ul>
