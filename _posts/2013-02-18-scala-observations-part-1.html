---
layout: post
title: Scala Observations - Part 1
categories:
- Scala
tags: []
status: publish
type: post
published: true
meta:
  _edit_last: '1'
---
<p>At my new workplace we will be using Scala with Play. I've never used Scala before so I'm taking some time to get familiar with the language. I'm working through the book "Scala for the Impatient", here's some various notes and snippets of what I've learned from the first handful of chapters.</p>
<ul>
	<li>Scala has values and variables. Values are immutable, variables aren't.</li>
	<li>You can delay evaluation of variables by putting in the <em>lazy</em> keyword beforehand. They will be evaluated upon first use.</li>
	<li>You typically don't want to use <em>return</em> in Scala because if you <em>return</em> in an anonymous function, you will break out of the caller. The last evaluation will be returned by default.</li>
	<li>Arrays and maps work about how you'd expect they do. Except you access things with () and not [].</li>
	<li>
<pre class="lang:default decode:true">def countOccurencesSorted(input:String)= {
    val in = new Scanner(input)
    var count = scala.collection.immutable.SortedMap[String,Int]()
    while (in.hasNext()) {
      val key = in.next()
      count = count + (key -&gt; (count.getOrElse(key, 0) + 1))
    }
    count
  }</pre>
</li>
	<li>If you don't have <strong>function =<em> </em></strong>it will return the <em>Unit</em> type which is the equivalent of void in Java.</li>
	<li>
<pre class="lang:java decode:true" title="function">def foo(input:String) = {
  input * 10
}</pre>
</li>
	<li>You usually don't need to declare the return type of a function, it will be inferred. However, if you plan on using the function recursively you have to define it or else the compiler will not know whether it's valid or not.</li>
	<li>Declaring type in Scala is kind of strange...the type comes after the variable name, like <strong>foo: String</strong></li>
	<li>Scala can use Java classes and convert between them if need be.</li>
	<li>
<pre class="lang:java decode:true ">def countOccurencesJava(input:String) = {
    import scala.collection.JavaConversions.mapAsScalaMap
    val in = new Scanner(input)
    var count: scala.collection.mutable.Map[String,Int] = new java.util.TreeMap[String, Int]()
    while (in.hasNext()) {
      val key = in.next()
      count = count + (key -&gt; (count.getOrElse(key, 0) + 1))
    }
    count
  }</pre>
</li>
	<li>Class fields in Scala are autogenerated from the <em>primary constructor. </em>Depending on the type of field declared, getters and/or setters will be generated.</li>
	<li><em>Auxiliary constructors </em>take the form <strong>this</strong> see below:</li>
	<li>
<pre class="lang:java decode:true">class Car(val manufacturer:String, val model_name:String){
  private var model_year:Int = -1
  var license_plate:String = ""

  def this(man:String, mod:String, mod_year:Int){
    this(man, mod)
    model_year = mod_year
  }

  def this(man:String, mod:String, plate:String){
    this(man, mod)
    license_plate = plate
  }

  def this(man:String, mod:String, mod_year:Int, plate:String){
    this(man, mod, mod_year)
    model_year = mod_year
    license_plate = plate
  }

  def mod_year = model_year
}</pre>
</li>
	<li>Methods default to public, as do fields. Adding private in front of fields will make them available to class (like in Java), you can make it instance-only by using <em>private[this]</em>.</li>
	<li>You can define methods without () and they will only be callable via <em>class.method </em>and not <em>class.method()</em></li>
	<li>Tuple access is 1-indexed, and you use <em>_&lt;index&gt;</em> to do it.</li>
	<li>Multiple args in a sequence are denoted by _*.</li>
	<li>Typical for loop functionality <em>(init; test; update)</em> as it exists in Java and C++ is not present in Scala. For loops look like this:</li>
	<li>
<pre class="lang:java decode:true">for (i &lt;- 0 until n){
    arr += random.nextInt(n)
}
// until is exclusive, to is inclusive

// backwards
for (i &lt;- n to 0 by -1){
    println(i)
}</pre>
</li>
	<li>Scaladoc is your friend.</li>
</ul>
